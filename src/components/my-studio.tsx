"use client";

/* eslint-disable @typescript-eslint/no-misused-promises */
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "./ui/alert-dialog"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "./ui/dialog"


/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/1frRkxHriYN
 */
import { Badge } from "src/components/ui/badge"
import { Button } from "src/components/ui/button"
import { Cross1Icon } from "@radix-ui/react-icons"
import { Pencil } from "lucide-react"
import { abbrDaytoFull } from "lib/utils"
import { Progress } from "./ui/progress"

// Dynamic imports for dialog components
const ManualScheduleDialog = dynamic(() => import("./ManualScheduleDialog"), {
  loading: () => <div className="animate-pulse bg-gray-200 h-8 w-24 rounded" />
})
const SendToStudentsDialog = dynamic(() => import("./SendToStudentsDialog"), {
  loading: () => <div className="animate-pulse bg-gray-200 h-8 w-24 rounded" />
})
const SetAvailabilityDialog = dynamic(() => import("./SetAvailabilityDialog"), {
  loading: () => <div className="animate-pulse bg-gray-200 h-8 w-24 rounded" />
})
const SolveScheduleDialog = dynamic(() => import("./SolveScheduleDialog"), {
  loading: () => <div className="animate-pulse bg-gray-200 h-8 w-24 rounded" />
})
const EditStudentScheduleDialog = dynamic(() => import("./EditStudentScheduleDialog"), {
  loading: () => <div className="animate-pulse bg-gray-200 h-8 w-24 rounded" />
})
import { Task } from "./Task"
import type { StudioWithStudents } from "@/app/(protected)/studios/[slug]/page"
import { useState, useMemo } from "react"
import dynamic from "next/dynamic"
import type { StudentSchema } from "lib/db-types"
import { createClient } from "@/utils/supabase/client"
import { useRouter } from "next/navigation"
import { Popover, PopoverContent, PopoverTrigger } from "./ui/popover"
// InteractiveCalendar removed - legacy component deleted
import { useSchedule } from "../hooks/useSchedule"

// Dynamic import for heavy AdaptiveCalendar component
const AdaptiveCalendar = dynamic(
  () => import("./scheduling/AdaptiveCalendar").then(mod => ({ default: mod.AdaptiveCalendar })),
  {
    loading: () => <div className="animate-pulse bg-gray-200 h-96 rounded-lg" />,
    ssr: false
  }
)
import { createEmptyWeekSchedule } from "lib/scheduling/utils"
import type { WeekSchedule } from "lib/scheduling/types"
import type { Schedule } from "lib/types"
import { convertScheduleToWeekSchedule } from "lib/scheduling-adapter"
import { dayNames, timeBlockToString } from "lib/scheduling/display-utils"

// Event type previously from InteractiveCalendar - now defined inline
export interface Event {
  id: string;
  name: string;
  booking: {
    day: string;
    timeInterval: { start: number; duration: number };
  };
  student_id: number;
}

type Props = {
  studio: StudioWithStudents,
  setStudio: (studio: StudioWithStudents) => void,
}

type Task = {
  name: string,
  dialogComponent: React.ReactNode,
}

export const AVAILABILITY = 0
export const SEND_CODE = 1
export const CREATE_SCHEDULE = 2
const isPaid = true

// Legacy grid system variables removed

type Progress = "Not Started" | "In Progress" | "Completed"

export const eventListToEltList = (events: Event[]): React.JSX.Element[] => {
  const res = []
  const daysOfWeekAbbv = ["M", "Tu", "W", "Th", "F", "Sa", "Su"];
  
  // Helper function to convert minutes to time string
  const minutesToTimeString = (minutes: number): string => {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours}:${mins.toString().padStart(2, '0')}`;
  };
  
  for (let i = 0; i < 7; i++) {
    const day = daysOfWeekAbbv[i]!
    const dayEvents = events.filter(event => event.booking.day === day);
    if (dayEvents.length > 0) {
      res.push(<p key={`${day}-header`} className="font-bold">{abbrDaytoFull(day)}:</p>);
      dayEvents.forEach((event, index) => {
        const startTime = minutesToTimeString(event.booking.timeInterval.start);
        const endTime = minutesToTimeString(event.booking.timeInterval.start + event.booking.timeInterval.duration);
        res.push(<div key={`${day}-${index}`}>{event.name}: {startTime} - {endTime}</div>);
      });
    }
  }
  return res
}

const getStudentProgress = (student: StudentSchema) => {
  return student.schedule === null ?  "Not Started" : "Completed"
}

const formatStudentAvailability = (student: StudentSchema) => {
  if (!student.schedule) {
    return "No availability set"
  }

  const weekSchedule = convertScheduleToWeekSchedule(student.schedule)
  const availableDays: string[] = []

  weekSchedule.days.forEach((day, index) => {
    if (day.blocks && day.blocks.length > 0) {
      const dayName = dayNames[index]
      const timeRanges = day.blocks.map(block => timeBlockToString(block)).join(", ")
      availableDays.push(`${dayName}: ${timeRanges}`)
    }
  })

  if (availableDays.length === 0) {
    return "No availability set"
  }

  const lessonDuration = student.lesson_duration_minutes 
    ? `${student.lesson_duration_minutes} min lessons`
    : student.lesson_length === "30" ? "30 min lessons" : "60 min lessons"

  return `${availableDays.join('\n')}\n\nPreferred: ${lessonDuration}`
}

// Note: Event metadata is now stored directly in TimeBlock.metadata

// Convert Events array to WeekSchedule format for calendar display
const convertEventsToWeekSchedule = (events: Event[]): WeekSchedule => {
  const weekSchedule = createEmptyWeekSchedule()
  const dayAbbrevs = ['Su', 'M', 'Tu', 'W', 'Th', 'F', 'Sa']
  
  events.forEach(event => {
    const dayIndex = dayAbbrevs.indexOf(event.booking.day)
    if (dayIndex >= 0 && weekSchedule.days[dayIndex]) {
      const block = {
        start: event.booking.timeInterval.start,
        duration: event.booking.timeInterval.duration,
        metadata: {
          studentId: event.student_id,
          studentName: event.name,
          eventId: event.id
        }
      }
      
      weekSchedule.days[dayIndex].blocks.push(block)
    }
  })
  
  // Recalculate metadata for each day
  weekSchedule.days.forEach(day => {
    day.metadata = {
      totalAvailable: day.blocks.reduce((sum, block) => sum + block.duration, 0),
      largestBlock: Math.max(...day.blocks.map(block => block.duration), 0),
      fragmentationScore: day.blocks.length > 1 ? day.blocks.length - 1 : 0
    }
  })
  
  return weekSchedule
}

// Convert WeekSchedule back to Events array
const convertWeekScheduleToEvents = (weekSchedule: WeekSchedule): Event[] => {
  const dayAbbrevs = ['Su', 'M', 'Tu', 'W', 'Th', 'F', 'Sa']
  const events: Event[] = []
  
  weekSchedule.days.forEach((day, dayIndex) => {
    day.blocks.forEach(block => {
      // Use embedded metadata instead of the global map
      if (block.metadata) {
        events.push({
          id: block.metadata.eventId,
          name: block.metadata.studentName,
          booking: {
            day: dayAbbrevs[dayIndex]!,
            timeInterval: {
              start: block.start,
              duration: block.duration
            }
          },
          student_id: block.metadata.studentId
        })
      }
    })
  })
  
  return events
}

// Note: isTimeSlotValid function removed - validation now handled in AdaptiveCalendar component

// Helper function to convert WeekSchedule to JSON format for database storage
const convertWeekScheduleToJson = (weekSchedule: WeekSchedule): Record<string, unknown> => {
  const jsonSchedule: Record<string, unknown> = {
    Monday: undefined,
    Tuesday: undefined,
    Wednesday: undefined,
    Thursday: undefined,
    Friday: undefined,
    Saturday: undefined,
    Sunday: undefined,
  };

  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  
  weekSchedule.days.forEach((day) => {
    const dayName = dayNames[day.dayOfWeek];
    if (dayName && day.blocks.length > 0) {
      jsonSchedule[dayName] = day.blocks.map(block => ({
        start: {
          hour: Math.floor(block.start / 60),
          minute: block.start % 60
        },
        end: {
          hour: Math.floor((block.start + block.duration) / 60),
          minute: (block.start + block.duration) % 60
        }
      }));
    }
  });

  return jsonSchedule;
};

export function MyStudio(props: Props) {
  const supabaseClient = createClient()
  const router = useRouter()

  const { studio, setStudio } = props

  // Use the new TimeBlock-based schedule hook
  const { 
    schedule: weekSchedule, 
    updateSchedule, 
    saving, 
    error: scheduleError,
    saveImmediately 
  } = useSchedule(studio.id)

  // TODO: populate this from DB on boot
  const [taskStatus, setTaskStatus] = useState<boolean[]>([(studio.owner_schedule !== null && studio.owner_schedule !== undefined), studio.students.length !== 0, studio.events !== null])
  
  // Legacy boolean grid availability removed - using WeekSchedule system instead

  // Note: Task status for availability is only updated on actual database saves,
  // not on local schedule changes, to prevent progress counter incrementing prematurely

  // Show error if schedule fails to load
  if (scheduleError) {
    console.error("Schedule loading error:", scheduleError);
  }

  const [taskOpen, setTaskOpen] = useState<boolean[]>([false, false, false])
  const [resolveOpen, setResolveOpen] = useState<boolean>(false)
  const [unscheduledStudents, setUnscheduledStudents] = useState<string[]>(studio.unscheduled_students ?? [])
  const [editAvailability, setEditAvailability] = useState<boolean>(false)
  const [editingStudent, setEditingStudent] = useState<StudentSchema | null>(null)
  
  // State for tracking dragged student from unscheduled list
  const [draggedStudent, setDraggedStudent] = useState<{
    studentId: string;
    studentName: string;
    lessonDuration: number;
    studentDbId: number;
  } | null>(null)

  // Using events directly for schedule display
  const [events, setEvents] = useState<Event[]>((studio.events as Event[]) ?? [])

  const handleSaveSchedule = async () => {
    if (!events) {
      console.log("events is null")
      return
    }
    const res = await supabaseClient.from("studios").update({
      events: events
    }).eq("id", studio.id)

    if (res.error) {
      console.log(res.error)
      alert("error, please try again")
    }

    setStudio({ ...studio, events: events })
  }

  const hasScheduleChanged = JSON.stringify(events) !== JSON.stringify(studio.events)

  // Helper function to check why a student can't be scheduled
  const getUnscheduledReason = (studentEmail: string): string => {
    const student = studio.students.find(s => s.email === studentEmail);
    if (!student?.schedule) return "No availability set";
    
    if (!weekSchedule) return "Teacher availability not set";
    
    // Check for overlapping availability
    const studentSchedule = convertScheduleToWeekSchedule(student.schedule);
    let hasAnyOverlap = false;
    
    for (let day = 0; day < 7; day++) {
      const teacherBlocks = weekSchedule.days[day]?.blocks ?? [];
      const studentBlocks = studentSchedule.days[day]?.blocks ?? [];
      
      for (const teacherBlock of teacherBlocks) {
        for (const studentBlock of studentBlocks) {
          const overlapStart = Math.max(teacherBlock.start, studentBlock.start);
          const overlapEnd = Math.min(
            teacherBlock.start + teacherBlock.duration,
            studentBlock.start + studentBlock.duration
          );
          const lessonDuration = parseInt(student.lesson_length ?? '60');
          
          if (overlapEnd > overlapStart && (overlapEnd - overlapStart) >= lessonDuration) {
            hasAnyOverlap = true;
            break;
          }
        }
        if (hasAnyOverlap) break;
      }
      if (hasAnyOverlap) break;
    }
    
    if (!hasAnyOverlap) {
      return "No overlapping time with teacher availability";
    }
    
    return "Scheduling conflict with other students";
  }

  // Handle schedule changes from AdaptiveCalendar - validation now handled in calendar component
  const handleScheduleChange = (newSchedule: WeekSchedule) => {
    // Convert back to events - AdaptiveCalendar will handle validation internally
    const newEvents = convertWeekScheduleToEvents(newSchedule)
    setEvents(newEvents)
  }

  // Handle dropping a student from unscheduled list onto calendar
  const handleStudentDrop = async (studentData: {
    studentId: string;
    studentName: string;
    lessonDuration: number;
    studentDbId: number;
  }, dayIndex: number, startMinute: number) => {
    try {
      // Create new event
      const dayAbbrevs = ['Sun', 'M', 'Tu', 'W', 'Th', 'F', 'Sat'];
      const newEvent: Event = {
        id: Date.now().toString(),
        name: studentData.studentName,
        booking: {
          day: dayAbbrevs[dayIndex] ?? 'M',
          timeInterval: {
            start: startMinute,
            duration: studentData.lessonDuration
          }
        },
        student_id: studentData.studentDbId
      };

      // Add to events
      const updatedEvents = [...events, newEvent];
      setEvents(updatedEvents);

      // Remove from unscheduled list
      const updatedUnscheduled = unscheduledStudents.filter(id => id !== studentData.studentId);
      setUnscheduledStudents(updatedUnscheduled);

      // Update in database
      const updateRes = await supabaseClient
        .from("studios")
        .update({ 
          events: updatedEvents,
          unscheduled_students: updatedUnscheduled 
        })
        .eq("id", studio.id);

      if (updateRes.error) {
        console.error(updateRes.error);
        throw new Error("Error updating studio with new schedule");
      }

      setStudio({
        ...studio,
        events: updatedEvents,
        unscheduled_students: updatedUnscheduled
      });

    } catch (error) {
      console.error('Error scheduling student:', error);
      // TODO: Add toast notification for error
    }
  }

  const handleAvailabilitySubmit = async () => {
    try {
      // Force immediate save to ensure data is persisted before updating task status
      if (weekSchedule && saveImmediately) {
        await saveImmediately();
        
        // Convert WeekSchedule to JSON format for studio state sync
        const jsonSchedule = convertWeekScheduleToJson(weekSchedule);
        
        // Update local studio state to include the saved schedule
        setStudio({
          ...studio,
          owner_schedule: jsonSchedule as Schedule
        });
        
        console.log("Synced studio state with saved teacher schedule", jsonSchedule);
        
        const hasAvailability = weekSchedule.days.some(day => day.blocks.length > 0);
        setTaskStatus(taskStatus.map((status, i) => AVAILABILITY === i ? hasAvailability : status))
      }
      setTaskOpen(taskOpen.map((status, i) => AVAILABILITY === i ? false : status))
    } catch (error) {
      console.error("Error saving availability:", error)
      alert("Error saving availability, please try again")
    }
  }

  const handleStudentDelete = async (student: StudentSchema) => {
    console.log("Attempting to delete student:", student.id, student.email)
    const res = await supabaseClient.from("students").delete().eq("id", student.id)

    console.log("Delete result:", res)
    if (res.error) {
      console.error("Delete error:", res.error)
      alert(`Error deleting student: ${res.error.message}`)
      return
    }

    // Check if any rows were actually deleted
    if (res.count === 0) {
      console.error("No rows were deleted - likely RLS policy issue")
      alert("Failed to delete student - permission denied")
      return
    }

    // Remove student from students array
    const newStudents = studio.students.filter((s) => s.id !== student.id)
    
    // Remove any events for this student
    const filteredEvents = events.filter((event) => event.student_id !== student.id)
    
    // Remove student from unscheduled list if they're there
    const filteredUnscheduled = unscheduledStudents.filter((email) => email !== student.email)

    // Update database with cleaned data
    const updateRes = await supabaseClient
      .from("studios")
      .update({ 
        events: filteredEvents,
        unscheduled_students: filteredUnscheduled 
      })
      .eq("id", studio.id)

    if (updateRes.error) {
      console.error(updateRes.error)
      alert("Error updating studio data, please try again")
      return
    }

    // Update all local state
    setEvents(filteredEvents)
    setUnscheduledStudents(filteredUnscheduled)
    const newStudio = { 
      ...studio, 
      students: newStudents,
      events: filteredEvents,
      unscheduled_students: filteredUnscheduled
    }
    props.setStudio(newStudio)
  }

  const handleEditAvailability = async () => {
    try {
      // Force immediate save to ensure data is persisted before updating task status
      if (weekSchedule && saveImmediately) {
        await saveImmediately();
        
        // Convert WeekSchedule to JSON format for studio state sync
        const jsonSchedule = convertWeekScheduleToJson(weekSchedule);
        
        // Update local studio state to include the saved schedule
        setStudio({
          ...studio,
          owner_schedule: jsonSchedule as Schedule
        });
        
        console.log("Synced studio state with updated teacher schedule", jsonSchedule);
        
        // Update task status based on whether schedule has availability blocks
        const hasAvailability = weekSchedule.days.some(day => day.blocks.length > 0);
        setTaskStatus(taskStatus.map((status, i) => AVAILABILITY === i ? hasAvailability : status))
      }
      setEditAvailability(false)
    } catch (error) {
      console.error("Error updating availability:", error)
      alert("Error updating availability, please try again")
    }
  }

  // Memoize availability data to prevent infinite re-renders
  const { teacherAvailability, studentAvailabilities } = useMemo(() => {
    const teacherAvail = studio.owner_schedule ? convertScheduleToWeekSchedule(studio.owner_schedule) : undefined;
    const studentAvail = new Map<string, WeekSchedule>();
    
    // Build map of student availabilities
    studio.students.forEach(student => {
      if (student.schedule) {
        studentAvail.set(
          student.id.toString(),
          convertScheduleToWeekSchedule(student.schedule)
        );
      }
    });
    
    return {
      teacherAvailability: teacherAvail,
      studentAvailabilities: studentAvail
    };
  }, [studio.owner_schedule, studio.students]);

  const tasks: Task[] = [
    {
      name: "Set your availability",
      dialogComponent: <SetAvailabilityDialog 
        handleSubmit={handleAvailabilitySubmit}
        schedule={weekSchedule}
        onScheduleChange={updateSchedule}
        saving={saving}
        showWeekends={studio.calendar_days === 'full_week'}
      />
    },
    {
      name: "Send out code to students",
      dialogComponent: <SendToStudentsDialog 
        taskStatus={taskStatus} 
        setTaskStatus={setTaskStatus}
        taskIdx={SEND_CODE}
        setOpen={(input: boolean) => {
          setTaskOpen(taskOpen.map((status, i) => SEND_CODE === i ? input : status))
        }}
        studio={studio}
        />
    },
    {
      name: "Create your schedule",
      dialogComponent: <SolveScheduleDialog 
        studio={studio}
        setTaskStatus={setTaskStatus}
        taskStatus={taskStatus}
        taskIdx={CREATE_SCHEDULE}
        setStudio={setStudio}
        setEvents={setEvents}
        setUnscheduledStudents={setUnscheduledStudents}
      />
    },
  ]

  const handleStudioDelete = async () => {
    
    const res = await supabaseClient.from("studios").delete().eq("id", studio.id)

    if (res.error) {
      console.log(res.error)
      alert("error, please try again")
    }

    router.push("/studios")
  }

  // Memoize expensive computations
  const isDoneWithTasks = useMemo(() => taskStatus.every((status) => status), [taskStatus])
  
  const taskProgress = useMemo(() => {
    const completed = taskStatus.reduce((acc, curr) => acc + (curr ? 1 : 0), 0)
    return {
      completed,
      percentage: (completed / taskStatus.length) * 100
    }
  }, [taskStatus])
  
  const scheduledEvents = useMemo(() => events ?? [], [events])
  
  const scheduleWeek = useMemo(() => 
    convertEventsToWeekSchedule(scheduledEvents),
    [scheduledEvents]
  )

  return (
    <main className="container mx-auto px-4 py-4">
      {!isDoneWithTasks && (
        <section className="mt-2 mb-2">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-bold text-landing-blue">Progress</h2>
            <Badge className="bg-landing-blue text-white">{taskProgress.completed}/3</Badge>
          </div>
          <Progress className="mt-2" value={taskProgress.percentage
        }/>
        </section>)
      }
      <header className="mb-4 flex flex-row items-end justify-between">
        <div>
          <h1 className="text-4xl font-bold tracking-tight text-landing-blue">{studio.studio_name}</h1>
        </div>
        <h3 className="text-xl tracking-tight font-light text-landing-blue/70">Studio Code: {studio.code}</h3>
      </header>
      <div className="flex space-x-10">
        {isDoneWithTasks ? 
        ( <>
          <div className="space-y-6 w-2/3">
            <div className="h-[45vh]">
              <AdaptiveCalendar 
                schedule={scheduleWeek}
                onChange={handleScheduleChange}
                granularity={15}
                mode="rearrange"
                showWeekends={studio.calendar_days === 'full_week'}
                teacherAvailability={teacherAvailability}
                studentAvailabilities={studentAvailabilities}
                showStudentNames={true}
                onStudentDrop={handleStudentDrop}
                draggedStudent={draggedStudent}
              />
            </div>
          </div>
          
          {/* Unscheduled Students Section */}
          {unscheduledStudents.length > 0 && (
            <div className="w-full mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
              <h3 className="text-lg font-medium text-yellow-800 mb-2">
                Unscheduled Students ({unscheduledStudents.length})
              </h3>
              {/* <p className="text-sm text-yellow-700 mb-3">
                These students couldn&apos;t be automatically scheduled. Drag them to available time slots on the calendar.
              </p> */}
              <p className="text-sm text-yellow-700 mb-3">
                These students couldn&apos;t be automatically scheduled.
              </p>
              <div className="flex flex-wrap gap-2">
                {unscheduledStudents.map((studentId) => {
                  const student = studio.students.find(s => s.email === studentId);
                  return student ? (
                    <div 
                      key={studentId}
                      className="px-3 py-2 bg-white border border-yellow-300 rounded-md cursor-move hover:bg-yellow-100 shadow-sm"
                      draggable
                      title={`${student.first_name} ${student.last_name} - ${student.lesson_length ?? '60'}min lessons\nReason: ${getUnscheduledReason(student.email)}`}
                      onDragStart={(e) => {
                        const studentData = {
                          studentId: student.email,
                          studentName: `${student.first_name} ${student.last_name}`,
                          lessonDuration: parseInt(student.lesson_length ?? '60'),
                          studentDbId: student.id
                        };
                        e.dataTransfer.setData("application/json", JSON.stringify(studentData));
                        e.dataTransfer.effectAllowed = "move";
                        setDraggedStudent(studentData);
                      }}
                      onDragEnd={() => {
                        setDraggedStudent(null);
                      }}
                    >
                      <div className="flex flex-col">
                        <span className="text-sm font-medium text-landing-blue/70">
                          {student.first_name} {student.last_name}
                        </span>
                        <div className="flex items-center justify-between">
                          <span className="text-xs text-landing-blue/60">
                            ({student.lesson_length ?? '60'}min)
                          </span>
                          <span className="text-xs text-red-500 ml-2">
                            {getUnscheduledReason(student.email)}
                          </span>
                        </div>
                      </div>
                    </div>
                  ) : null;
                })}
              </div>
            </div>
          )}
          {(events && events.length > 0) || unscheduledStudents.length > 0 ? (
          <div className="w-1/4">
            <h3 className="text-lg font-light text-landing-blue">Schedule:</h3>
            <div className="flex flex-col">
                {eventListToEltList(events ?? []).map((elt) => (
                    elt
                ))}
                {unscheduledStudents.length > 0 && (
                  <>
                    <p className="font-bold text-red-600 mt-4">Unscheduled:</p>
                    {unscheduledStudents.map((studentId) => {
                      const student = studio.students.find(s => s.email === studentId);
                      return student ? (
                        <div key={studentId} className="text-red-600">
                          {student.first_name} {student.last_name}: Not scheduled
                        </div>
                      ) : null;
                    })}
                  </>
                )}
            </div>
            {/* <Button className="mt-4">Download Schedule</Button> */}
            {hasScheduleChanged && 
              <Button 
                className="mt-4 bg-landing-blue text-white hover:bg-landing-blue-hover"
                onClick={handleSaveSchedule}
              >
                Save Changes
              </Button>
            }
          </div>) : null}
          </>
        ) : 
        (<section className="space-y-6 w-2/3">
          {tasks.map((task, i) => (
            <Task
              key={i}
              taskStatus={taskStatus}
              task={task.name}
              i={i}
              setTaskStatus={setTaskStatus}
              open={taskOpen[i]!}
              setOpen={(input: boolean) => {
                setTaskOpen(taskOpen.map((status, j) => i === j ? input : status))
              }}
            >
              {task.dialogComponent}
            </Task>
          ))}
        </section>)}
        <aside className="w-1/3 space-y-6">
          <section className="bg-white border border-landing-blue/20 p-4 rounded-md">
            <div className="flex flex-row w-full mb-4">
              <h2 className="text-xl font-bold w-full text-landing-blue">Enrolled Students</h2>
              <p className="text-right w-full text-landing-blue/70">{studio.students.length} / {isPaid ? 50 : 10} students</p>
              {/* TODO: add a tooltip to explain the limit if the user isnt premium */}
            </div>
            <ul className="space-y-2 flex flex-col max-h-[40vh] overflow-y-auto">
              {studio.students.length ? (studio.students.map((student) => {
                const progress = getStudentProgress(student)
                return (
                <li key={student.id} className="flex flex-row w-full justify-between">
                  <div className="flex flex-row justify-start items-center">
                    {/* make sure the border has a thin radius and is a circle */}
                    <div 
                      className="w-5 h-5 cursor-pointer hover:bg-landing-blue/10 flex flex-row items-center p-1 border border-landing-blue/30 rounded-full mr-1"
                      onClick={() => handleStudentDelete(student)}
                    >
                      <Cross1Icon className="" />
                    </div>
                    <Popover>
                      <PopoverTrigger>
                        <p className="font-mono px-1 border rounded-md border-landing-blue/20 cursor-pointer self-start text-left text-landing-blue">{student.first_name} {student.last_name}, {student.email}</p>
                      </PopoverTrigger>
                      <PopoverContent className="min-w-[20vw]">
                        <div className="p-4">
                          <div className="text-sm text-landing-blue/70 whitespace-pre-line font-mono">
                            {formatStudentAvailability(student)}
                          </div>
                        </div>
                      </PopoverContent>
                    </Popover>
                  </div>
                  <div className="flex flex-row items-center gap-2">
                    <Badge 
                    className={`min-w-[6.5vw] flex flex-row justify-center h-6 self-center border-landing-blue text-landing-blue
                    ${progress === "Completed" && "bg-landing-blue text-white"}
                    `}
                    >{progress}</Badge>
                    {progress === "Completed" && (
                      <button
                        onClick={() => setEditingStudent(student)}
                        className="w-5 h-5 flex items-center justify-center hover:bg-landing-blue/10 rounded-sm transition-colors"
                        title="Edit student schedule"
                      >
                        <Pencil className="w-3 h-3 text-landing-blue/70 hover:text-landing-blue" />
                      </button>
                    )}
                  </div>
                </li>
              )})) : <p className="text-center text-landing-blue/70">No students have been invited or enrolled yet!</p>}
            </ul>
          </section>
          <section className="bg-white border border-landing-blue/20 p-4 rounded-md">
            <h2 className="text-xl font-bold mb-4 text-landing-blue">Admin Tasks</h2>
            <div className="space-y-2">
              <Dialog 
                open={taskOpen[SEND_CODE]} 
                onOpenChange={(input: boolean) => {
                  setTaskOpen(taskOpen.map((status, i) => SEND_CODE === i ? input : status))
                }}
              >
                <DialogTrigger asChild>
                  <Button className="w-full bg-landing-blue text-white hover:bg-landing-blue-hover">Invite Students</Button>
                </DialogTrigger>
                <SendToStudentsDialog 
                  taskStatus={taskStatus} 
                  setTaskStatus={setTaskStatus}
                  taskIdx={SEND_CODE}
                  setOpen={(input: boolean) => {
                    setTaskOpen(taskOpen.map((status, i) => SEND_CODE === i ? input : status))
                  }}
                  studio={studio}
                />
              </Dialog>
              <ManualScheduleDialog 
                studio={studio}
                setStudio={props.setStudio}
                events={events}
                setEvents={setEvents}
                taskStatus={taskStatus}
                setTaskStatus={setTaskStatus}
              />
              {taskStatus[AVAILABILITY] && 
              <Dialog open={editAvailability} onOpenChange={setEditAvailability}>
                <DialogTrigger asChild>
                  <Button className="w-full bg-landing-blue text-white hover:bg-landing-blue-hover">Edit Your Availability</Button>
                </DialogTrigger>
                <SetAvailabilityDialog 
                  handleSubmit={handleEditAvailability}
                  schedule={weekSchedule}
                  onScheduleChange={updateSchedule}
                  saving={saving}
                  showWeekends={studio.calendar_days === 'full_week'}
                />
              </Dialog>
              }
              <Dialog>
                <DialogTrigger asChild>
                  <Button className="w-full bg-landing-blue text-white hover:bg-landing-blue-hover">Manage Studio</Button>
                </DialogTrigger>
                <DialogContent className="w-[50vw] max-h-[50vh] flex flex-col justify-center items-center">
                  <DialogHeader>
                    <DialogTitle>Manage Studio</DialogTitle>
                    <DialogDescription>
                      Change your studio info, or delete the studio.
                    </DialogDescription>
                  </DialogHeader>
                  {/* <div>
                    <Label>Studio Name</Label>
                    <div className="flex flex-row justify-center items-center">
                      <Input className="w-[20vw]" placeholder="Studio Name" />
                      <Button className="mx-2"><CheckIcon className="w-4 h-4" /></Button>
                    </div>
                  </div> */}
                  {/* <Separator /> */}
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button className="w-[10vw]"variant="destructive">Delete Studio</Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                        <AlertDialogDescription>
                          This action cannot be undone. This will permanently delete your
                          studio and remove the data from our servers.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={handleStudioDelete}>Continue</AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </DialogContent>
              </Dialog>
              {taskStatus[CREATE_SCHEDULE] && 
                <Dialog open={resolveOpen} onOpenChange={setResolveOpen}>
                  <DialogTrigger asChild>
                    <Button className="w-full bg-landing-blue text-white hover:bg-landing-blue-hover">Re-Solve Schedule</Button>
                  </DialogTrigger>
                  <SolveScheduleDialog 
                    studio={studio}
                    setTaskStatus={setTaskStatus}
                    taskStatus={taskStatus}
                    taskIdx={CREATE_SCHEDULE}
                    setEvents={setEvents}
                    setStudio={setStudio}
                    setResolveOpen={setResolveOpen}
                    setUnscheduledStudents={setUnscheduledStudents}
                  />
                </Dialog>
              }
            </div>
          </section>
        </aside>
      </div>
      
      {/* Edit Student Schedule Dialog */}
      {editingStudent && (
        <EditStudentScheduleDialog
          student={editingStudent}
          studio={studio}
          setStudio={setStudio}
          events={events}
          setEvents={setEvents}
          setUnscheduledStudents={setUnscheduledStudents}
          open={!!editingStudent}
          onClose={() => setEditingStudent(null)}
        />
      )}
    </main>
  )
}

